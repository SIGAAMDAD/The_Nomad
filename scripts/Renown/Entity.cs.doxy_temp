/*
===========================================================================
Copyright (C) 2023-2025 Noah Van Til

This file is part of The Nomad source code.

The Nomad source code is free software; you can redistribute it
and/or modify it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version.

The Nomad source code is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with The Nomad source code; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
===========================================================================
*/

using Godot;
using Renown.World;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace Renown {
	/*!
	===================================================================================
	
	Entity
	
	the base class from which all entities inherit from
	
	===================================================================================
	*/
	
	public partial class Entity : CharacterBody2D, Object {
		[ExportCategory( "Base Stats" )]
		[Export]
		public float Health { get; private set; } = 0.0f;
		[Export]
		public int RenownScore { get; private set; } = 0;

		[Export]
		public WorldArea? Location { get; private set; } = null;

		[ExportCategory( "Faction" )]
		[Export]
		public Faction? Faction { get; private set; } = null;
		[Export]
		public int FactionImportance { get; private set; } = 0;

		protected Dictionary<string, StatusEffect> StatusEffects = new Dictionary<string, StatusEffect>();

		[Signal]
		public delegate void DamagedEventHandler( Entity source, Entity target, float nAmount );
		[Signal]
		public delegate void DieEventHandler( Entity source, Entity target );

		/*
		===============
		SetLocation
		===============
		*/
		public virtual void SetLocation( in WorldArea location ) {
			Location = location;
		}

		/*
		===============
		Save
		===============
		*/
		public virtual void Save() {
		}

		/*
		===============
		Load
		===============
		*/
		public virtual void Load() {
		}

		/*
		 * narrative functions
		 */


		/*
		===============
		OnChallenged
		===============
		*/
		public virtual void OnChallenged() {
		}

		/*
		===============
		OnIntimidated
		===============
		*/
		public virtual void OnIntimidated() {
			float crueltyScore = LevelData.Instance.ThisPlayer.GetTraitScore( TraitType.Cruel );
		}

		/*
		===============
		ClearStatusEffects
		===============
		*/
		public virtual void ClearStatusEffects() {
			foreach ( var effect in StatusEffects ) {
				effect.Value.Stop();
			}
			StatusEffects.Clear();
		}

		/*
		===============
		AddStatusEffects
		===============
		*/
		public virtual void AddStatusEffect( string effectName ) {
			if ( effectName == null || effectName.Length == 0 ) {
				Console.PrintError( $"Entity.AddStatusEffect: invalid effectName (null or empty)" );
				return;
			}
			if ( StatusEffects.TryGetValue( effectName, out StatusEffect? data ) ) {
				data.ResetTimer();
				return;
			}

			PackedScene scene = ResourceCache.GetScene( $"res://scenes/status_effects/{effectName}.tscn" );
			if ( scene == null ) {
				Console.PrintError(
					$"Entity.AddStatusEffect: invalid effect, ensure that all status effects are located in res://scenes/status_effects/ as scene files"
				);
				return;
			}

			StatusEffect effect = scene.Instantiate<StatusEffect>();
			effect.SetVictim( this );
			StatusEffects.Add( effectName, effect );
			effect.Timeout += () => {
				CallDeferred( MethodName.RemoveChild, effect );
				effect.CallDeferred( MethodName.QueueFree );
				StatusEffects.Remove( effectName );
			};
			CallDeferred( MethodName.AddChild, effect );
		}

		/*
		===============
		PickupWeapon
		===============
		*/
		public virtual void PickupWeapon( WeaponEntity weapon ) {
		}

		/*!
		===============
		PlaySound

		plays a sound effect from the provided channel and stream local to the entity's position
		===============
		*/
		public virtual void PlaySound( AudioStreamPlayer2D channel, AudioStream stream ) {
			if ( channel == null ) {
				Console.PrintError( "Entity.PlaySound: channel is null" );
				return;
			}
			
			// no need to check stream here since it'll just stay silent
			channel.Stream = stream;
			channel.Play();
		}

		/*
		===============
		Damage
		===============
		*/
		public virtual void Damage( in Entity source, float nAmount ) {
			EmitSignalDamaged( source, this, nAmount );
			Health -= nAmount;

			if ( Health <= 0.0f ) {
				EmitSignalDie( source, this );
			}
		}

		/*
		===============
		HasRelation
		===============
		*/
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		public virtual bool HasRelation( Object other ) {
			return false;
		}

		/*
		===============
		GetRelationScore
		===============
		*/
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		public virtual float GetRelationScore( Object other ) {
			return 0.0f;
		}

		/*
		===============
		GetRelationStatus
		===============
		*/
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		public virtual RelationStatus GetRelationStatus( Object other ) {
			return RelationStatus.Neutral;
		}

		/*
		===============
		DetermineRelationStatus
		===============
		*/
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		public virtual void DetermineRelationStatus( Object other ) {
		}

		/*
		===============
		GetHash
		===============
		*/
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		public NodePath GetHash() {
			return GetPath();
		}

		/*
		===============
		GetObjectName
		===============
		*/
		[MethodImpl( MethodImplOptions.AggressiveInlining )]
		public virtual StringName GetObjectName() {
			return "Entity";
		}

		/*!
		===============
		_Ready

		godot initialization override
		===============
		*/
		public override void _Ready() {
			base._Ready();

			if ( LevelData.Instance != null ) {
				LevelData.Instance.PlayerRespawn += ClearStatusEffects;
			}

			EntityManager.RegisterProcess( this );
			EntityManager.RegisterPhysicsProcess( this );
		}

		/*
		===============
		Update
		===============
		*/
		public virtual void Update( double delta ) {
		}

		/*
		===============
		PhysicsUpdate
		===============
		*/
		public virtual void PhysicsUpdate( double delta ) {
		}
	};
};